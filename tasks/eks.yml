---
# Example of role with custom trust policy for Lambda service
- name: Create IAM role with custom trust relationship
  iam:
    iam_type: role
    name: "{{ eks_service_role }}"
    state: present
    region: "{{ region }}"
    aws_access_key: "{{ aws_access_key }}"
    aws_secret_key: "{{ aws_secret_key }}" 
    trust_policy:
      Version: '2012-10-17'
      Statement:
        - Action: sts:AssumeRole
          Effect: Allow
          Principal:
            Service: ec2.amazonaws.com
        - Action: sts:AssumeRole
          Effect: Allow
          Principal:
            Service: eks.amazonaws.com
        - Action: sts:AssumeRole
          Effect: Allow
          Principal:
            AWS: "arn:aws:iam::{{ aws_account_id }}:user/{{ iam_user }}"
  register: role  


- name: attach policy to role
  shell: |
      aws configure set aws_access_key_id {{ aws_access_key }}
      aws configure set aws_secret_access_key {{ aws_secret_key }}
      aws configure set default.region {{ region }}
      aws iam tag-role --tags '{"Key": "kubernetes.io/cluster/{{ vpc_name }}", "Value": "shared" } ' --role-name {{ eks_service_role }}
      aws iam attach-role-policy --policy-arn arn:aws:iam::aws:policy/AmazonEKSServicePolicy --role-name {{ eks_service_role }}
      aws iam attach-role-policy --policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy --role-name {{ eks_service_role }}
      aws iam create-instance-profile --instance-profile-name {{ code_name }}-ec2-Instance-Profile
      aws iam add-role-to-instance-profile --instance-profile-name {{ code_name }}-ec2-Instance-Profile --role-name {{ eks_service_role }}

##      aws eks create-cluster --name {{ code_name }}_eks --role-arn {{ role.role_result.arn }} --resources-vpc-config subnetIds={{ subnet_1.subnet.id }},{{ subnet_2.subnet.id }},securityGroupIds={{ security_group.group_id }}

 
- name: Create EC2 server
  ec2:
    image: ami-467ca739
    wait: yes
    instance_type: t2.micro
    region: "{{ region }}"
    group_id: "{{ security_group.group_id }}"
    vpc_subnet_id: "{{ subnet_1.subnet.id }}"
    key_name: "{{ keypair.key.name  }}"
    count_tag:
      Name: apacheserver
    instance_tags:
        db: postgres
        code_name: "{{ code_name }}"    
    volumes:
      - device_name: /dev/xvda
        volume_type: gp2
        volume_size: 8
        delete_on_termination: true           
    exact_count: 1
    aws_access_key: "{{ aws_access_key }}"
    aws_secret_key: "{{ aws_secret_key }}"
  register: ec2

- debug:
    var: ec2

- name: Create an EKS cluster
  aws_eks_cluster:
    region: "{{ region }}"
    aws_access_key: "{{ aws_access_key }}"
    aws_secret_key: "{{ aws_secret_key }}"    
    name: "{{ code_name }}_eks"
    role_arn: "{{ role.role_result.arn }}"
    wait: yes
    subnets:
      - "{{ subnet_1.subnet.id }}"
      - "{{ subnet_2.subnet.id }}"
    security_groups:
      - "{{ security_group.group_id }}"
  register: caller_facts

# - name: create a stack, specify role that cloudformation assumes
#   cloudformation:
#     stack_name: "{{ code_name }}-cloudformation"
#     region: "{{ region }}"
#     aws_access_key: "{{ aws_access_key }}"
#     aws_secret_key: "{{ aws_secret_key }}" 
#     state: "present"
#     disable_rollback: true
#     template: "files/service-role.yml"
#   register: role

# - debug:
#     var: role


# Basic role example
# - name: create a stack, specify role that cloudformation assumes
#   cloudformation:
#     stack_name: "{{ code_name }}-cloudformation"
#     region: "{{ region }}"
#     aws_access_key: "{{ aws_access_key }}"
#     aws_secret_key: "{{ aws_secret_key }}" 
#     state: "present"
#     disable_rollback: true
#     template: "files/amazon-eks-vpc-private-subnets.yaml"
#     role_arn: "{{ role.stack_outputs.RoleArn }}"

- name: update kubeconfig
  shell: |
      aws eks --region {{ region }} update-kubeconfig --kubeconfig ./{{ code_name }}-config.yml --name {{ caller_facts.name }}

